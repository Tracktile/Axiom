{"version":3,"sources":["../src/cli/index.ts","../src/server/service.ts","../src/common/index.ts","../src/common/typebox.ts","../src/common/model.ts","../src/common/procedure.ts","../src/common/utils.ts","../src/common/errors.ts","../src/index.ts","../src/common/search.ts","../src/common/resource.ts","../src/cli/generate.ts","../src/server/combined-service.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Static, Type as T } from \"@sinclair/typebox\";\nimport { Value } from \"@sinclair/typebox/value\";\nimport fs from \"fs\";\nimport loadConfig from \"load-config-file\";\nimport path from \"path\";\nimport { parse } from \"ts-command-line-args\";\n\nimport { isService } from \"../server/service\";\nimport { generate } from \"./generate\";\n\nloadConfig.register(\"json\", (text) => JSON.parse(text));\n\nconst AxiomCliConfig = T.Object({\n  entry: T.String({ default: \"index.ts\" }),\n  output: T.String({ default: \"api.yaml\" }),\n  internal: T.Boolean({ default: false }),\n  format: T.Union([T.Literal(\"json\"), T.Literal(\"yaml\")], { default: \"yaml\" }),\n  sections: T.Optional(\n    T.Array(\n      T.Object({\n        title: T.String(),\n        tags: T.Array(T.String()),\n      })\n    )\n  ),\n});\n// eslint-disable-next-line @typescript-eslint/no-redeclare\ntype AxiomCliConfig = Static<typeof AxiomCliConfig>;\n\nconst AxiomCliArgs = T.Object({\n  config: T.Optional(T.String()),\n  help: T.Optional(T.Boolean()),\n});\n// eslint-disable-next-line @typescript-eslint/no-redeclare\ntype AxiomCliArgs = Static<typeof AxiomCliArgs>;\n\nconst fatal = (message: string) => {\n  // eslint-disable-next-line no-console\n  console.error(`[X] ${message}`);\n  process.exit(1);\n};\n\nconst info = (...args: any[]) => {\n  // eslint-disable-next-line no-console\n  console.info(\"[*]\", ...args);\n};\n\nconst processArgs = () => {\n  try {\n    const args = parse<AxiomCliArgs>(\n      {\n        config: {\n          type: String,\n          optional: true,\n          description: \"Path to an axiom.config.json file.\",\n          defaultValue: \"axiom.config.json\",\n        },\n        help: {\n          type: Boolean,\n          optional: true,\n          alias: \"h\",\n          description: \"Displays this useful screen!\",\n        },\n      },\n      {\n        helpArg: \"help\",\n        headerContentSections: [\n          {\n            header: \"Axiom\",\n            content:\n              \"A batteries included Typescript API framework, but like.. watch batteries.\",\n          },\n        ],\n      }\n    );\n    return args;\n  } catch (err) {\n    if (err instanceof Error) {\n      return fatal(err.message);\n    }\n    return fatal(\"Error encountered while process arguments.\");\n  }\n};\n\nconst recurseDefaultExports = (imported: { default?: unknown }): unknown => {\n  if (imported.default) {\n    return recurseDefaultExports(imported.default);\n  }\n  return imported;\n};\n\nasync function loadEntry(entry: string) {\n  const imported = await import(entry);\n  const service = recurseDefaultExports(imported);\n  return service;\n}\n\nfunction getConfig(configPath?: string) {\n  try {\n    // const loaded = loadConfig.loadSync(configPath ?? \"axiom.config\");\n    // const resolvedPath = path.resolve(loaded.$cfgPath as string);\n    const config = Value.Cast(AxiomCliConfig, {});\n\n    // Rewrite entry and output to absolute paths based on the config file.\n    config.entry = path.resolve(config.entry);\n    config.output = path.resolve(config.output);\n\n    return config;\n  } catch (err) {\n    if (err instanceof Error) {\n      return fatal(\n        `Unable to resolve configuration: ${configPath ?? \"axiom.config\"}: ${err.message}`\n      );\n    }\n    return fatal(\"Unable to resolve configuration.\");\n  }\n}\n\nasync function main() {\n  const args = processArgs();\n  const config = getConfig(args.config);\n  const service = await loadEntry(config.entry);\n\n  if (!isService(service)) {\n    return fatal(\"Entry file does not export a valid service.\");\n  }\n\n  const content = await generate(service, config);\n  fs.writeFileSync(path.resolve(config.output), content, { encoding: \"utf8\" });\n  info(\"Specification written to:\", path.resolve(config.output));\n}\n\nmain();\n","import { Options as CorsOptions } from \"@koa/cors\";\nimport Router from \"@koa/router\";\nimport Koa, { DefaultState, Middleware } from \"koa\";\nimport BodyParser from \"koa-bodyparser\";\nimport KoaQs from \"koa-qs\";\nimport sizeOf from \"object-sizeof\";\nimport prettyBytes from \"pretty-bytes\";\n\nimport {\n  convertQueryParamKeysFromKabobCase,\n  ErrorType,\n  isAPIError,\n  isBadRequestError,\n  isForbiddenError,\n  isInternalServerError,\n  isNotFoundError,\n  isUnauthorizedError,\n} from \"../common\";\nimport { Controller } from \"./controller\";\n\nexport type Contact = {\n  name: string;\n  email: string;\n  url: string;\n};\n\nexport type License = {\n  name: string;\n  url: string;\n};\n\nexport type Server = {\n  description: string;\n  url: string;\n};\n\nexport interface ServiceOptions<TExtend = Record<string, never>> {\n  title?: string;\n  description?: string;\n  tags?: string[];\n  prefix?: string;\n  version?: string;\n  internal?: boolean;\n  license?: License;\n  contact?: Contact;\n  servers?: Server[];\n  controllers?: Controller<TExtend>[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  middlewares?: Middleware<DefaultState, any>[];\n  config?: Partial<ServiceConfiguration>;\n  onError?: (error: Error) => void;\n}\n\nexport interface ServiceConfiguration {\n  /**\n   * Options for the CORS middleware.\n   * See Koa Cors for more information.\n   */\n  cors?: CorsOptions;\n}\n\nexport const DEFAULT_SERVICE_CONFIGURATION: ServiceConfiguration = {\n  cors: {},\n} as const;\n\nexport function isService(service: unknown): service is Service {\n  if (typeof service !== \"object\" || service === null) {\n    return false;\n  }\n  return (\n    \"title\" in service &&\n    typeof service.title === \"string\" &&\n    \"description\" in service &&\n    typeof service.description === \"string\" &&\n    \"tags\" in service &&\n    Array.isArray(service.tags) &&\n    \"prefix\" in service &&\n    typeof service.prefix === \"string\"\n  );\n}\n\nexport class Service<TExtend = Record<string, unknown>> extends Koa<\n  DefaultState,\n  unknown\n> {\n  version: string;\n  title: string;\n  description: string;\n  tags: string[];\n  prefix: string;\n  internal: boolean;\n  contact: Contact;\n  license: License;\n  servers: Server[];\n  controllers: Controller<TExtend>[];\n  children: Service<TExtend>[];\n  middleware: Middleware<DefaultState, unknown>[];\n  router: Router<DefaultState, TExtend>;\n  config: ServiceConfiguration;\n  onError?: (error: Error) => void;\n\n  constructor({\n    title = \"\",\n    description = \"\",\n    prefix = \"\",\n    version = \"\",\n    servers = [{ description: \"\", url: \"\" }],\n    contact = { name: \"\", email: \"\", url: \"\" },\n    license = { name: \"\", url: \"\" },\n    internal = false,\n    tags = [],\n    controllers = [],\n    middlewares = [],\n    config = DEFAULT_SERVICE_CONFIGURATION,\n    onError,\n  }: ServiceOptions<TExtend>) {\n    super();\n    this.router = new Router<DefaultState, TExtend>();\n    this.version = version;\n    this.children = [];\n    this.title = title;\n    this.description = description;\n    this.tags = tags;\n    this.internal = internal;\n    this.contact = contact;\n    this.license = license;\n    this.servers = servers;\n    this.prefix = prefix;\n    this.controllers = controllers;\n    this.middleware = middlewares as Middleware<DefaultState, unknown>[];\n    this.config = { ...DEFAULT_SERVICE_CONFIGURATION, ...config };\n    this.onError = onError;\n  }\n\n  register(controller: Controller<TExtend>) {\n    this.controllers.push(controller);\n  }\n\n  bind(target: Router<DefaultState, TExtend> = this.router) {\n    const serviceRouter = new Router<DefaultState, unknown>();\n\n    serviceRouter.use(BodyParser());\n\n    serviceRouter.use(async (ctx, next) => {\n      await next();\n      const resBodySize = sizeOf(ctx.body);\n\n      // If the response body size is approaching the lambda limit (6MB), log an error to the handler. (Sentry)\n      if (resBodySize > 5 * 1024 * 1024) {\n        this.onError?.(\n          new Error(\n            `Response body size (${prettyBytes(resBodySize)}) is approaching the lambda limit (6MB)`\n          )\n        );\n      }\n\n      // If response body size is greated than the lambda limit (6MB), log an error to the handler. (Sentry)\n      if (resBodySize > 6 * 1024 * 1024) {\n        this.onError?.(\n          new Error(\n            `Response body size (${prettyBytes(resBodySize)}) is greater than the lambda limit (6MB)`\n          )\n        );\n      }\n    });\n\n    serviceRouter.use(async (ctx, next) => {\n      try {\n        await next();\n      } catch (err) {\n        if (err instanceof Error) {\n          this.onError?.(err);\n          if (isAPIError(err) && isBadRequestError(err)) {\n            ctx.body = {\n              type: ErrorType.BadRequest,\n              message: err.message,\n              status: 400,\n              fields: err.fields,\n            };\n            ctx.status = 400;\n          }\n          if (isAPIError(err) && isUnauthorizedError(err)) {\n            ctx.body = {\n              type: ErrorType.Unauthorized,\n              message: err.message,\n              status: 401,\n            };\n            ctx.status = 401;\n          }\n          if (isAPIError(err) && isForbiddenError(err)) {\n            ctx.body = {\n              type: ErrorType.Forbidden,\n              message: err.message,\n              status: 403,\n            };\n            ctx.status = 403;\n          }\n          if (isAPIError(err) && isNotFoundError(err)) {\n            ctx.body = {\n              type: ErrorType.NotFound,\n              message: err.message,\n              status: 404,\n            };\n            ctx.status = 404;\n          }\n          if (isAPIError(err) && isInternalServerError(err)) {\n            ctx.body = {\n              type: ErrorType.InternalServerError,\n              message: err.message,\n              status: 500,\n            };\n            ctx.status = 500;\n          }\n          if (!isAPIError(err)) {\n            ctx.body = {\n              type: ErrorType.InternalServerError,\n              message: \"An internal server error occurred.\",\n              status: 500,\n            };\n            ctx.status = 500;\n          }\n        } else {\n          ctx.body = {\n            type: ErrorType.InternalServerError,\n            message: \"An internal server error occurred.\",\n            status: 500,\n          };\n          ctx.status = 500;\n        }\n      }\n    });\n\n    // Transform null's in request bodies back to undefined\n    serviceRouter.use((ctx, next) => {\n      if (\n        [\"POST\", \"PUT\", \"PATCH\"].includes(ctx.method) &&\n        ctx.request.body &&\n        typeof ctx.request.body === \"object\"\n      ) {\n        ctx.request.body = Object.fromEntries(\n          Object.entries(ctx.request.body).map(([key, value]) => [\n            key,\n            value === null ? undefined : value,\n          ])\n        );\n      }\n      return next();\n    });\n\n    // Transform query parameters back from kebab case to dotted format\n    // Ex. customer-name => customer.name\n    serviceRouter.use((ctx, next) => {\n      if (typeof ctx.query === \"object\") {\n        ctx.query = convertQueryParamKeysFromKabobCase(ctx.query);\n      }\n      return next();\n    });\n\n    serviceRouter.use(...this.middleware);\n\n    for (const controller of this.controllers) {\n      controller.service = this;\n      controller.bind(serviceRouter);\n    }\n\n    if (![\"\", \"/\"].includes(this.prefix)) {\n      target.use(this.prefix, serviceRouter.routes());\n      target.use(this.prefix, serviceRouter.allowedMethods());\n    } else {\n      target.use(serviceRouter.routes());\n      target.use(serviceRouter.allowedMethods());\n    }\n  }\n\n  init(target: Router<DefaultState, TExtend> = this.router) {\n    this.bind(target);\n    this.use(this.router.routes());\n    this.use(this.router.allowedMethods());\n  }\n\n  start(port = 8080, addresses: string[] = [\"127.0.0.1\"]) {\n    KoaQs(this as Koa, \"extended\");\n    this.init();\n    for (const address of addresses) {\n      this.listen(port, address);\n    }\n  }\n}\n","export * from \"./typebox\";\nexport * from \"./model\";\nexport * from \"./procedure\";\nexport * from \"./utils\";\nexport * from \"./types\";\nexport * from \"./errors\";\nexport * from \"./search\";\nexport * from \"./resource\";\n","export * from \"@sinclair/typebox\";\nexport { Type as T, TypeGuard } from \"@sinclair/typebox\";\nexport { Value } from \"@sinclair/typebox/value\";\nexport { TypeCompiler } from \"@sinclair/typebox/compiler\";\nexport { TypeSystem } from \"@sinclair/typebox/system\";\n","import { Static, T, TObject, TSchema } from \"../common\";\n\nexport type ModelOptions<\n  TModel extends TSchema,\n  TCreate extends TSchema,\n  TUpdate extends TSchema,\n  TDelete extends TSchema,\n  TQuery extends TSchema,\n  TPath extends TSchema,\n  TTransform extends (serialized: Static<TModel>) => any,\n  TSortable extends TSchema,\n> = {\n  name: string;\n  resource: string;\n  idKey: Exclude<keyof Static<TModel>, symbol>;\n  model: TModel;\n  create?: TCreate;\n  update?: TUpdate;\n  del?: TDelete;\n  query?: TQuery;\n  path?: TPath;\n  transformer: TTransform;\n  sortableBy?: TSortable;\n  _unstable_offlineModel?: boolean;\n  infiniteSearch?: {\n    enabled: boolean;\n    defaultLimit?: number;\n  };\n};\n\nexport class Model<\n  TModel extends TSchema,\n  TCreate extends TSchema = TModel,\n  TUpdate extends TSchema = TModel,\n  TDelete extends TSchema = TObject,\n  TQuery extends TSchema = TObject,\n  TPath extends TSchema = TObject,\n  TTransform extends (serialized: Static<TModel>) => any = (\n    m: Static<TModel>\n  ) => typeof m,\n  TSortable extends TSchema = TModel,\n> {\n  name: string;\n  resource: string;\n  idKey: Exclude<keyof Static<TModel>, symbol>;\n  schemas: {\n    model: TModel;\n    create: TCreate;\n    update: TUpdate;\n    del: TDelete;\n    query: TQuery;\n    path: TPath;\n  };\n  transformer: TTransform;\n  sortableBy: TSortable;\n  _unstable_offlineModel?: boolean;\n  infiniteSearch?: {\n    enabled: boolean;\n    defaultLimit: number;\n  };\n\n  constructor(\n    options: ModelOptions<\n      TModel,\n      TCreate,\n      TUpdate,\n      TDelete,\n      TQuery,\n      TPath,\n      TTransform,\n      TSortable\n    >\n  ) {\n    this.name = options.name;\n    this.resource = options.resource;\n    this.idKey = options.idKey;\n    this.schemas = {\n      model: options.model,\n      create: options.create ?? (options.model as unknown as TCreate),\n      update: options.update ?? (options.model as unknown as TUpdate),\n      del: options.del ?? (T.Object({}) as unknown as TDelete),\n      path: options.path ?? (T.Object({}) as unknown as TPath),\n      query: options.query ?? (T.Object({}) as unknown as TQuery),\n    };\n    this.transformer = options.transformer;\n    this.sortableBy =\n      options.sortableBy || (options.model as unknown as TSortable);\n    this._unstable_offlineModel = options._unstable_offlineModel ?? false;\n    this.infiniteSearch = options.infiniteSearch\n      ? {\n          enabled: options.infiniteSearch.enabled,\n          defaultLimit: options.infiniteSearch.defaultLimit ?? 50,\n        }\n      : undefined;\n  }\n\n  getSearchResponseType(): TSchema {\n    return T.Object({\n      results: T.Array(this.schemas.model),\n      nextCursor: T.Optional(T.String()),\n      total: T.Number(),\n      metadata: T.Object({\n        currentResults: T.Number(),\n        historicalResults: T.Number(),\n        timePeriodCovered: T.Tuple([T.String(), T.String()]),\n      }),\n    });\n  }\n\n  getSearchParamsType(): TSchema {\n    return T.Object({\n      cursor: T.Optional(T.String()),\n      limit: T.Optional(T.Number()),\n      search: T.Optional(T.String()),\n      filters: T.Optional(\n        T.Array(\n          T.Object({\n            field: T.String(),\n            operator: T.Union([\n              T.Literal(\"eq\"),\n              T.Literal(\"contains\"),\n              T.Literal(\"gt\"),\n              T.Literal(\"lt\"),\n              T.Literal(\"between\"),\n            ]),\n            value: T.Union([\n              T.String(),\n              T.Number(),\n              T.Boolean(),\n              T.Array(T.Union([T.String(), T.Number()])),\n            ]),\n          })\n        )\n      ),\n      sort: T.Optional(\n        T.Object({\n          field: T.String(),\n          direction: T.Union([T.Literal(\"asc\"), T.Literal(\"desc\")]),\n        })\n      ),\n    });\n  }\n}\n\nexport function createModel<\n  TModel extends TSchema,\n  TCreate extends TSchema,\n  TUpdate extends TSchema,\n  TDelete extends TSchema,\n  TQuery extends TSchema,\n  TPath extends TSchema,\n  TTransformer extends (serialized: Static<TModel>) => any,\n  TSortable extends TSchema = TModel,\n>(\n  options: ModelOptions<\n    TModel,\n    TCreate,\n    TUpdate,\n    TDelete,\n    TQuery,\n    TPath,\n    TTransformer,\n    TSortable\n  >\n) {\n  return new Model<\n    TModel,\n    TCreate,\n    TUpdate,\n    TDelete,\n    TQuery,\n    TPath,\n    TTransformer,\n    TSortable\n  >(options);\n}\n","import { T, TSchema } from \"../common\";\n\nexport interface ProcedureOptions<\n  TParams extends TSchema,\n  TQuery extends TSchema,\n  TResult extends TSchema,\n> {\n  name: string;\n  resource: string;\n  params: TParams;\n  result: TResult;\n  query?: TQuery;\n  method?: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n}\n\nexport class Procedure<\n  TParams extends TSchema,\n  TQuery extends TSchema,\n  TResult extends TSchema,\n> {\n  name: string;\n  resource: string;\n  method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" = \"GET\";\n  params: TParams;\n  query: TQuery;\n  result: TResult;\n\n  constructor(options: ProcedureOptions<TParams, TQuery, TResult>) {\n    this.name = options.name;\n    this.resource = options.resource;\n    this.params = options.params;\n    this.result = options.result;\n    this.query = options.query ?? (T.Object({}) as unknown as TQuery);\n    this.method = options.method || \"GET\";\n  }\n}\n\nexport function createProcedure<\n  TParams extends TSchema,\n  TQuery extends TSchema,\n  TResult extends TSchema,\n>(options: ProcedureOptions<TParams, TQuery, TResult>) {\n  return new Procedure(options);\n}\n","import { Value, Type, Static, TSchema, TypeGuard, TObject } from \"./typebox\";\nimport { GetFieldType } from \"./types\";\n\nexport function convertQueryParamKeysToKabobCase<T extends object>(obj: T) {\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, val]) => [key.replace(/0/g, \".\"), val])\n  );\n}\n\nexport function convertQueryParamKeysFromKabobCase<T extends object>(obj: T) {\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, val]) => [key.replace(/,/g, \"-\"), val])\n  );\n}\n\nexport function getValue<\n  TData,\n  TPath extends string,\n  TDefault = GetFieldType<TData, TPath>,\n>(\n  data: TData,\n  path: TPath,\n  defaultValue?: TDefault\n): GetFieldType<TData, TPath> | TDefault {\n  const value = path\n    .split(/[.[\\]]/)\n    .filter(Boolean)\n    .reduce<GetFieldType<TData, TPath>>(\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      (value, key) => (value as any)?.[key],\n      data as any\n    );\n\n  return value !== undefined ? value : (defaultValue as TDefault);\n}\n\nexport function Nullable<T extends TSchema>(schema: T) {\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true });\n}\n\nexport function noAdditionalPropertiesInSchema<T extends TSchema>(\n  schema: T\n): T {\n  if (TypeGuard.IsArray(schema)) {\n    return { ...schema, items: noAdditionalPropertiesInSchema(schema.items) };\n  }\n  if (TypeGuard.IsObject(schema)) {\n    return {\n      ...schema,\n      additionalProperties: false,\n      properties: Object.fromEntries(\n        Object.entries(schema.properties).map(([key, value]) => [\n          key,\n          noAdditionalPropertiesInSchema(value),\n        ])\n      ),\n    };\n  }\n  return schema;\n}\n\nexport function withDefaultsForStringFormats<T extends TSchema>(schema: T): T {\n  if (TypeGuard.IsArray(schema)) {\n    return { ...schema, items: withDefaultsForStringFormats(schema.items) };\n  }\n  if (TypeGuard.IsObject(schema)) {\n    return {\n      ...schema,\n      properties: Object.fromEntries(\n        Object.entries(schema.properties).map(([key, value]) => [\n          key,\n          withDefaultsForStringFormats(value),\n        ])\n      ),\n    };\n  }\n  if (TypeGuard.IsString(schema) && typeof schema.format !== \"undefined\") {\n    return {\n      ...schema,\n      default: \"\",\n    };\n  }\n  return schema;\n}\n\nexport function withNoStringFormats<T extends TSchema>(schema: T): T {\n  if (TypeGuard.IsArray(schema)) {\n    return { ...schema, items: withNoStringFormats(schema.items) };\n  }\n  if (TypeGuard.IsObject(schema)) {\n    return {\n      ...schema,\n      properties: Object.fromEntries(\n        Object.entries(schema.properties).map(([key, value]) => [\n          key,\n          withNoStringFormats(value),\n        ])\n      ),\n    };\n  }\n  if (TypeGuard.IsString(schema) && typeof schema.format !== \"undefined\") {\n    return {\n      ...schema,\n      format: undefined,\n    };\n  }\n  return schema;\n}\n\nexport function withNoEnumValues<T extends TSchema>(schema: T): T {\n  if (TypeGuard.IsArray(schema)) {\n    return { ...schema, items: withNoEnumValues(schema.items) };\n  }\n  if (TypeGuard.IsObject(schema)) {\n    return {\n      ...schema,\n      properties: Object.fromEntries(\n        Object.entries(schema.properties)\n          .filter(([, value]) => {\n            return !TypeGuard.IsUnion(value);\n          })\n          .map(([key, value]) => [key, withNoEnumValues(value)])\n      ),\n    };\n  }\n  return schema;\n}\n\nexport function withDatesAsDateTimeStrings<T extends TSchema>(schema: T): T {\n  if (TypeGuard.IsArray(schema)) {\n    return { ...schema, items: withDatesAsDateTimeStrings(schema.items) };\n  }\n  if (TypeGuard.IsObject(schema)) {\n    return {\n      ...schema,\n      properties: Object.fromEntries(\n        Object.entries(schema.properties).map(([key, value]) => [\n          key,\n          withDatesAsDateTimeStrings(value),\n        ])\n      ),\n    };\n  }\n  if (TypeGuard.IsDate(schema)) {\n    return {\n      ...schema,\n      type: \"string\",\n      format: \"date-time\",\n    };\n  }\n  return schema;\n}\n\nexport function noEmptyStringValues<T extends object>(obj: T): Partial<T> {\n  return Object.entries(obj).reduce((acc, [key, val]) => {\n    if (val !== \"\") {\n      return { ...acc, [key]: val };\n    }\n    return acc;\n  }, {} as Partial<T>);\n}\n\nexport function noAdditionalProperties<T, I>(schema: T, input: I): I {\n  if (TypeGuard.IsArray(schema) && Array.isArray(input)) {\n    return input.map(\n      (item) => noAdditionalProperties(schema.items, item) as unknown as T\n    ) as I;\n  }\n  if (\n    TypeGuard.IsObject(schema) &&\n    typeof input === \"object\" &&\n    input !== null\n  ) {\n    const prunedInput: Partial<I> = {};\n    for (const [key, value] of Object.entries(input)) {\n      if (key in schema.properties) {\n        prunedInput[key as keyof I] = noAdditionalProperties(\n          schema.properties[key],\n          value\n        );\n      }\n    }\n    return prunedInput as I;\n  }\n  return input;\n}\n\nexport function shallowSchemaProperties<T extends TObject>(schema: T) {\n  return {\n    ...schema,\n    properties: Object.fromEntries(\n      Object.entries(schema.properties).filter(\n        ([, prop]) => !TypeGuard.IsArray(prop) && !TypeGuard.IsObject(prop)\n      )\n    ),\n  };\n}\n\nexport function undefinedToNull<T extends object>(input: T) {\n  return Object.fromEntries(\n    Object.entries(input).map(([key, value]) => [\n      key,\n      value === undefined ? null : value,\n    ])\n  );\n}\n\nexport function trueFalseStringsToBoolean<T extends object>(input: T) {\n  return Object.fromEntries(\n    Object.entries(input).map(([key, value]) => [\n      key,\n      value === \"true\" ? true : value === \"false\" ? false : value,\n    ])\n  );\n}\n\nexport function cast<T extends TSchema>(schema: T, value: unknown) {\n  return Value.Cast(schema, value);\n}\n","import { CustomError } from \"ts-custom-error\";\n\nexport enum ErrorType {\n  // 400\n  BadRequest = \"BadRequest\",\n  // 401\n  Unauthorized = \"Unauthorized\",\n  // 403\n  Forbidden = \"Forbidden\",\n  // 404\n  NotFound = \"NotFound\",\n  // 500\n  InternalServerError = \"InternalServerError\",\n}\n\nexport class APIError extends CustomError {\n  type: ErrorType;\n  status: number;\n  errors: Record<string, unknown>;\n  constructor(\n    status: number,\n    message: string,\n    errors: Record<string, string> = {}\n  ) {\n    super(message);\n    this.type = ErrorType.InternalServerError;\n    this.status = status;\n    this.errors = errors;\n  }\n}\n\nexport function isAPIError(error: unknown): error is APIError {\n  return (\n    !!error &&\n    typeof error === \"object\" &&\n    \"status\" in error &&\n    typeof error.status === \"number\"\n  );\n}\n\nexport class BadRequestError extends APIError {\n  fields: Record<string, string>;\n  constructor(message?: string, fieldErrors?: Record<string, string>) {\n    super(400, message || \"Bad Request\");\n    this.type = ErrorType.BadRequest;\n    this.fields = fieldErrors || {};\n  }\n}\n\nexport function isBadRequestError(error: APIError): error is BadRequestError {\n  return error.type === ErrorType.BadRequest && error.status === 400;\n}\n\nexport class UnauthorizedError extends APIError {\n  constructor(message?: string, errors?: Record<string, string>) {\n    super(401, message || \"Unauthorized\", errors);\n    this.type = ErrorType.Unauthorized;\n  }\n}\n\nexport function isUnauthorizedError(\n  error: APIError\n): error is UnauthorizedError {\n  return error.type === ErrorType.Unauthorized && error.status === 401;\n}\n\nexport class ForbiddenError extends APIError {\n  constructor(message?: string, errors?: Record<string, string>) {\n    super(403, message || \"Forbidden\", errors);\n    this.type = ErrorType.Forbidden;\n  }\n}\n\nexport function isForbiddenError(error: APIError): error is ForbiddenError {\n  return error.type === ErrorType.Forbidden && error.status === 403;\n}\n\nexport class NotFoundError extends APIError {\n  constructor(message?: string, errors?: Record<string, string>) {\n    super(404, message || \"Not Found\", errors);\n    this.type = ErrorType.NotFound;\n  }\n}\n\nexport function isNotFoundError(error: APIError): error is NotFoundError {\n  return error.type === ErrorType.NotFound && error.status === 404;\n}\n\nexport class InternalServerError extends APIError {\n  constructor(message?: string, errors?: Record<string, string>) {\n    super(500, message || \"Internal Server Error\", errors);\n    this.type = ErrorType.InternalServerError;\n  }\n}\n\nexport function isInternalServerError(\n  error: APIError\n): error is InternalServerError {\n  return error.type === ErrorType.InternalServerError && error.status === 500;\n}\n\nexport const assert = (\n  condition: any,\n  message: string,\n  error = BadRequestError\n) => {\n  if (!condition) {\n    throw new error(message);\n  }\n};\n","export * from \"./common\";\n","import { T } from \"../\";\n\nexport interface SearchMetadata {\n  currentResults: number;\n  historicalResults: number;\n  timePeriodCovered: [string, string];\n}\n\nexport const SearchMetadataSchema = T.Object({\n  currentResults: T.Number(),\n  historicalResults: T.Number(),\n  timePeriodCovered: T.Tuple([T.String(), T.String()]),\n});\n\nexport interface SearchResponse<T> {\n  results: T[];\n  nextCursor?: string;\n  total: number;\n  metadata: SearchMetadata;\n}\n\nexport const SearchResponseSchema = T.Object({\n  results: T.Array(T.Any()),\n  nextCursor: T.Optional(T.String()),\n  total: T.Number(),\n  metadata: SearchMetadataSchema,\n});\n\nexport interface SearchFilter {\n  field: string;\n  operator: \"eq\" | \"contains\" | \"gt\" | \"lt\" | \"between\";\n  value: string | number | boolean | [string | number];\n}\n\nexport const SearchFilterSchema = T.Object({\n  field: T.String(),\n  operator: T.Union([\n    T.Literal(\"eq\"),\n    T.Literal(\"contains\"),\n    T.Literal(\"gt\"),\n    T.Literal(\"lt\"),\n    T.Literal(\"between\"),\n  ]),\n  value: T.Union([\n    T.String(),\n    T.Number(),\n    T.Boolean(),\n    T.Array(T.Union([T.String(), T.Number()])),\n  ]),\n});\n\nexport interface SearchParams {\n  cursor?: string;\n  limit: number;\n  search?: string;\n  sort?: {\n    field: string;\n    direction: \"asc\" | \"desc\";\n  };\n}\n\nexport const SearchParamsSchema = T.Object({\n  cursor: T.Optional(T.String()),\n  limit: T.Number(),\n  search: T.Optional(T.String()),\n  sort: T.Optional(\n    T.Object({\n      field: T.String(),\n      direction: T.Union([T.Literal(\"asc\"), T.Literal(\"desc\")]),\n    })\n  ),\n});\n\nexport type SearchQueryField = {\n  name: string;\n  comparator?: \"and\" | \"or\";\n  is?: string | number | boolean;\n  contains?: string;\n  isOneOf?: string[];\n  isLikeOneOf?: string[];\n  isGreaterThan?: string | number;\n  isLessThan?: string | number;\n  isBetween?: [string | number, string | number];\n  isNull?: boolean;\n};\n\nexport type OrderBy<T> = {\n  key: Exclude<keyof T, symbol>;\n  order: \"asc\" | \"desc\";\n};\n\nexport type SearchQuery<TSortable = Record<string, unknown>> = {\n  fields?: SearchQueryField[];\n  offset?: number;\n  limit?: number;\n  orderBy?: string | OrderBy<TSortable>;\n};\n\nexport type SearchQueryResult<T> = {\n  results: T[];\n  total: number;\n  offset?: number;\n  limit: number;\n};\n\nexport const encodeSearchQuery = <TSortable>(\n  fields: Required<SearchQuery<TSortable>>[\"fields\"]\n): Record<string, string> =>\n  fields.reduce(\n    (\n      acc,\n      {\n        name,\n        comparator,\n        is,\n        isNull,\n        isOneOf,\n        isLikeOneOf,\n        contains,\n        isGreaterThan,\n        isLessThan,\n        isBetween,\n      }\n    ) => {\n      if (typeof is !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator ? `${comparator}:${is}` : is,\n        };\n      }\n      if (typeof isNull !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator ? `${comparator}:!${isNull}` : `!${isNull}`,\n        };\n      }\n      if (typeof isOneOf !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator\n            ? `${comparator}:${isOneOf.join(\",\")}`\n            : isOneOf.join(\",\"),\n        };\n      }\n\n      if (typeof contains !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator ? `${comparator}:%${contains}%` : `%${contains}%`,\n        };\n      }\n\n      if (typeof isLikeOneOf !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator\n            ? `${comparator}:${isLikeOneOf.map((v) => `%${v}%`).join(\",\")}`\n            : isLikeOneOf.map((v) => `%${v}%`).join(\",\"),\n        };\n      }\n\n      if (typeof isGreaterThan !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator\n            ? `${comparator}:>${isGreaterThan}`\n            : `>${isGreaterThan}`,\n        };\n      }\n\n      if (typeof isLessThan !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator\n            ? `${comparator}:<${isLessThan}`\n            : `<${isLessThan}`,\n        };\n      }\n\n      if (typeof isBetween !== \"undefined\") {\n        return {\n          ...acc,\n          [name]: comparator\n            ? `${comparator}:>${isBetween[0]},<${isBetween[1]}`\n            : `>${isBetween[0]},<${isBetween[1]}`,\n        };\n      }\n\n      return acc;\n    },\n    {}\n  );\n\nfunction toNumberIfPossible(value: string | number): number | string {\n  if (typeof value === \"string\") {\n    const parsed = parseInt(value, 10);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n  return value as number;\n}\n\nexport function decodeSearchQuery(\n  query: Record<string, string>\n): SearchQueryField[] {\n  return Object.entries(query).reduce((acc, [name, val]) => {\n    const [comparatorStr, valuesStr] = val.includes(\":\")\n      ? val.split(\":\")\n      : [\"and\", val];\n\n    const comparator = comparatorStr === \"and\" ? \"and\" : \"or\";\n    const hasMany = valuesStr.includes(\",\");\n    const values = hasMany ? valuesStr.split(\",\") : [valuesStr];\n\n    // Is Between\n    if (\n      values.length === 2 &&\n      values[0].startsWith(\">\") &&\n      values[1].startsWith(\"<\")\n    ) {\n      acc.push({\n        name,\n        comparator,\n        isBetween: [\n          toNumberIfPossible(values[0].slice(1)),\n          toNumberIfPossible(values[1].slice(1)),\n        ],\n      });\n\n      // Is Less Than\n    } else if (valuesStr.startsWith(\"<\")) {\n      const [, value] = valuesStr.split(\"<\");\n      acc.push({\n        name,\n        comparator,\n        isLessThan: toNumberIfPossible(value),\n      });\n\n      // Is Greater Than\n    } else if (valuesStr.startsWith(\">\")) {\n      const [, value] = valuesStr.split(\">\");\n      acc.push({\n        name,\n        comparator,\n        isGreaterThan: toNumberIfPossible(value),\n      });\n\n      // Is Like One Of\n    } else if (\n      values.length > 1 &&\n      valuesStr.startsWith(\"%\") &&\n      valuesStr.endsWith(\"%\")\n    ) {\n      acc.push({\n        name,\n        comparator,\n        isLikeOneOf: values.map((v) => v.slice(1, -1)),\n      });\n\n      // Contains\n    } else if (valuesStr.startsWith(\"%\") && valuesStr.endsWith(\"%\")) {\n      acc.push({\n        name,\n        comparator,\n        contains: valuesStr.slice(1, -1),\n      });\n\n      // Is One Of\n    } else if (values.length > 1) {\n      acc.push({\n        name,\n        comparator,\n        isOneOf: values,\n      });\n      // Is Null\n    } else if (values.length === 1 && valuesStr.startsWith(\"!\")) {\n      acc.push({\n        name,\n        comparator,\n        isNull: valuesStr === \"!true\",\n      });\n      // Is\n    } else {\n      acc.push({\n        name,\n        comparator,\n        is: toNumberIfPossible(valuesStr),\n      });\n    }\n\n    return acc;\n  }, [] as SearchQueryField[]);\n}\n","import { TSchema } from \"./typebox\";\n\nexport interface ResourceOptions<\n  TResp extends TSchema,\n  TParams extends TSchema,\n> {\n  name: string;\n  resource: string;\n  schema: TResp;\n  params: TParams;\n}\n\nexport class Resource<TResp extends TSchema, TParams extends TSchema> {\n  name: string;\n  resource: string;\n  schema: TResp;\n  params: TParams;\n\n  constructor(options: ResourceOptions<TResp, TParams>) {\n    this.name = options.name;\n    this.resource = options.resource;\n    this.schema = options.schema;\n    this.params = options.params;\n  }\n}\n\nexport function createResource<TResp extends TSchema, TParams extends TSchema>(\n  options: ResourceOptions<TResp, TParams>\n): Resource<TResp, TParams> {\n  return new Resource(options);\n}\n","import \"reflect-metadata\";\nimport convert from \"@openapi-contrib/json-schema-to-openapi-schema\";\nimport { TSchema, TypeGuard } from \"@sinclair/typebox\";\nimport { debug } from \"debug\";\nimport kebabCase from \"kebab-case\";\nimport * as oa from \"openapi3-ts\";\n\nimport { Controller } from \"../server\";\nimport { withDatesAsDateTimeStrings } from \"../common/utils\";\nimport { CombinedService, isCombinedService } from \"../server/combined-service\";\nimport { Service } from \"../server/service\";\nimport { OperationDefinition } from \"../server/types\";\n\nconst log = debug(\"axiom:cli:generate\");\n\nexport type Services<TContext = Record<string, never>> = {\n  resource: string;\n  service: Service<TContext>;\n}[];\n\nasync function convertToOpenAPI<TSchema>(schema: TSchema) {\n  const converted = convert(schema as object);\n  return converted;\n}\n\nconst formatPath = (path: string) => {\n  const converted = path\n    .split(\"/\")\n    .map((part) => {\n      if (part.includes(\":\")) {\n        return `{${part.replace(\":\", \"\")}}`;\n      }\n      return part;\n    })\n    .join(\"/\");\n\n  if (converted === \"/\") {\n    return converted;\n  }\n\n  return converted.endsWith(\"/\")\n    ? converted.slice(0, converted.length - 1)\n    : converted;\n};\n\nconst kebab = (str: string) => {\n  const noSpaces = str.replace(/\\s/g, \"\");\n  return kebabCase(noSpaces).substring(1)?.toLocaleLowerCase() ?? \"\";\n};\n\ninterface GenerateOptions {\n  format: \"json\" | \"yaml\";\n  internal?: boolean;\n  sections?: { title: string; tags: string[] }[];\n}\n\nconst DEFAULT_GENERATE_OPTIONS: GenerateOptions = {\n  format: \"yaml\",\n};\n\nexport async function generate<TContext = Record<string, never>>(\n  target: Service<TContext> | CombinedService<TContext>,\n  {\n    format = \"yaml\",\n    internal = false,\n    sections = [],\n  }: GenerateOptions = DEFAULT_GENERATE_OPTIONS\n) {\n  log(\"Generating OpenAPI spec from service\", target);\n  const spec = oa.oas30.OpenApiBuilder.create()\n    .addTitle(target.title)\n    .addDescription(target.description)\n    .addVersion(target.version)\n    .addSecurityScheme(\"JWT\", {\n      bearerFormat: \"JWT\",\n      type: \"http\",\n      scheme: \"bearer\",\n      description:\n        \"The JWT received by authenticating to the /auth/login endpoint.\",\n    })\n    .addResponse(\"400\", {\n      description: \"Bad Request Error\",\n      content: {\n        \"application/json\": {\n          schema: {\n            properties: {\n              status: { type: \"number\" },\n              message: { type: \"string\" },\n            },\n            example: {\n              status: 400,\n              message:\n                \"A helpful error message indicating what was invalid about your request\",\n            },\n          },\n        },\n      },\n    })\n    .addResponse(\"401\", {\n      description: \"Unauthorized\",\n      content: {\n        \"application/json\": {\n          schema: {\n            properties: {\n              status: { type: \"number\" },\n              message: { type: \"string\" },\n            },\n            example: {\n              status: 401,\n              message: \"You must be authenticated to access this resource.\",\n            },\n          },\n        },\n      },\n    })\n    .addResponse(\"403\", {\n      description: \"Forbidden\",\n      content: {\n        \"application/json\": {\n          schema: {\n            properties: {\n              status: { type: \"number\" },\n              message: { type: \"string\" },\n            },\n            example: {\n              status: 403,\n              message:\n                \"Current user does not have permissions to access this resource.\",\n            },\n          },\n        },\n      },\n    })\n    .addResponse(\"500\", {\n      description: \"Internal Server Error\",\n      content: {\n        \"application/json\": {\n          schema: {\n            properties: {\n              status: { type: \"number\" },\n              message: { type: \"string\" },\n            },\n            example: {\n              status: 500,\n              message: \"Something has gone horribly wrong.\",\n            },\n          },\n        },\n      },\n    });\n\n  if (target.license) {\n    spec.addLicense(target.license);\n  }\n\n  for (const server of target.servers) {\n    spec.addServer(server);\n  }\n\n  if (isCombinedService(target)) {\n    log(\"Input is a combined service - adding tags for each service\");\n\n    if (target.logo) {\n      spec.rootDoc.info[\"x-logo\"] = {\n        url: target.logo,\n        altText: target.title,\n      };\n    }\n\n    target.children\n      .filter((service) => !service.internal || internal)\n      .forEach((service) => {\n        log(`Adding for service ${service.title}`);\n        spec.addTag({\n          name: service.title,\n          description: service.description,\n        });\n        service.tags = [service.title];\n      });\n  }\n\n  if (sections.length > 0) {\n    log(\"Adding x-tagGroups for each section\");\n    spec.rootDoc[\"x-tagGroups\"] = sections.map((section) => ({\n      name: section.title,\n      tags: section.tags,\n    }));\n  }\n\n  const operationsByPath: Record<\n    string,\n    (OperationDefinition<TSchema, TSchema, TSchema, TSchema> & {\n      controller: Controller<TContext>;\n      service: Service<TContext>;\n      group?: string;\n    })[]\n  > = {};\n\n  const services = isCombinedService(target) ? target.children : [target];\n\n  log(`Found ${services.length} services`);\n\n  services\n    .filter((service) => !service.internal || internal)\n    .forEach((service) => {\n      log(`Adding controllers for service ${service.title}`);\n      service.controllers\n        .filter((controller) => !controller.internal || internal)\n        .forEach((controller) => {\n          const ops = controller.getOperations();\n          log(`Found ${ops.length} operations for controller`);\n          ops.forEach(([op]) => {\n            log(\n              `Operation: ${op.method.toUpperCase()} ${controller.prefix}${\n                op.path\n              }: ${op.name}`\n            );\n            const path = `${\n              [\"\", \"/\"].includes(service.prefix) ? \"\" : service.prefix\n            }${controller.prefix}${op.path}`;\n\n            if (!Array.isArray(operationsByPath[path])) {\n              operationsByPath[path] = [];\n            }\n\n            operationsByPath[path].push({\n              ...op,\n              tags: [\n                ...new Set([...service.tags, ...controller.tags, ...op.tags]),\n              ],\n              controller,\n              service,\n            });\n          });\n        });\n    });\n\n  log(\"Iterating over operations by path to generate path parameters\");\n\n  for (const path of Object.keys(operationsByPath)) {\n    log(`Generating path parameters for path ${path}`);\n    let pathObj: oa.oas30.PathItemObject = {};\n    const operations = operationsByPath[path].filter((op) => {\n      return (!op.internal && !op.controller.internal) || internal;\n    });\n    log(`Found ${operations.length} operations for path ${path}`);\n\n    const [first] = operations;\n    if (first) {\n      log(`First operation: ${first.name} ${first.method} ${first.path}`);\n\n      pathObj.parameters = Object.keys(first.params.properties).map((key) => ({\n        name: key,\n        in: \"path\",\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        required: first.params.required.includes(key),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        schema: { type: \"string\", format: first.params.properties[key].format },\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        description: first.params.properties[key].description,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        example: first.params.properties[key].example,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        examples: first.params.properties[key].examples,\n      }));\n    }\n\n    log(`Path parameters: ${JSON.stringify(pathObj.parameters)}`);\n\n    for (const op of operations) {\n      log(`Generating operation ${op.name} ${op.method} ${op.path}`);\n      if (!TypeGuard.IsObject(op.params)) {\n        throw new Error(\n          `Invalid parameters provided to route, must be T.Object. ${op.name} ${op.method} ${op.path}`\n        );\n      }\n\n      if (!TypeGuard.IsObject(op.query)) {\n        throw new Error(\n          `Invalid query provided to route, must be T.Object. ${op.name} ${op.method} ${op.path}`\n        );\n      }\n\n      log(`req`, JSON.stringify(op.req, null, \"\"));\n      log(`res`, JSON.stringify(op.res, null, \"\"));\n\n      pathObj = {\n        ...pathObj,\n        [op.method]: {\n          operationId: kebab(op.name),\n          summary: op.summary ?? \"No Summary\",\n          description: op.description ? op.description : \"No description\",\n          tags: op.tags,\n          ...([\"post\", \"put\"].includes(op.method)\n            ? {\n                requestBody: {\n                  content: {\n                    \"application/json\": {\n                      schema: await convertToOpenAPI(\n                        withDatesAsDateTimeStrings(op.req)\n                      ),\n                    },\n                  },\n                },\n              }\n            : {}),\n          parameters: Object.keys(op.query.properties).map((prop) => ({\n            name: prop,\n            schema: {\n              type: \"string\",\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              format: op.query.properties[prop].format,\n            },\n            in: \"query\",\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            description: op.query.properties[prop].description,\n          })),\n          security: op.auth ? [{ JWT: [] }] : [],\n          responses: {\n            200: {\n              description: op.res.description ?? \"Success\",\n              content: {\n                \"application/json\": {\n                  schema: await convertToOpenAPI(\n                    withDatesAsDateTimeStrings(op.res)\n                  ),\n                },\n              },\n            },\n            400: { $ref: \"#/components/responses/400\" },\n            401: { $ref: \"#/components/responses/401\" },\n            403: { $ref: \"#/components/responses/403\" },\n            500: { $ref: \"#/components/responses/500\" },\n          } as oa.oas30.ResponsesObject,\n        } as oa.oas30.OperationObject,\n      };\n    }\n\n    log(`Adding path ${path}`, pathObj);\n\n    spec.addPath(formatPath(path), pathObj);\n  }\n\n  if (format === \"yaml\") {\n    return spec.getSpecAsYaml();\n  }\n  return spec.getSpecAsJson();\n}\n","import {\n  Contact,\n  DEFAULT_SERVICE_CONFIGURATION,\n  License,\n  Server,\n  Service,\n  ServiceConfiguration,\n  ServiceOptions,\n} from \"./service\";\n\nexport interface CombinedServiceConfiguration extends ServiceConfiguration {\n  title?: string;\n  description?: string;\n  tags?: string[];\n  logo?: string;\n  version?: string;\n  contact?: Contact;\n  license?: License;\n  servers?: Server[];\n  onError?: (err: Error) => void;\n}\n\nexport interface CombinedServiceOptions<TExtend = Record<string, never>>\n  extends ServiceOptions<TExtend> {\n  children: Service<TExtend>[];\n  logo?: string;\n}\n\nexport const DEFAULT_COMBINED_SERVICE_CONFIGURATION = {\n  ...DEFAULT_SERVICE_CONFIGURATION,\n  title: \"\",\n  description: \"\",\n  tags: [] as string[],\n  contact: {\n    name: \"\",\n    email: \"\",\n    url: \"\",\n  },\n  license: {\n    name: \"\",\n    url: \"\",\n  },\n} as const;\n\nexport function isCombinedService<TExtend = Record<string, never>>(\n  service: Service<TExtend> | CombinedService<TExtend>\n): service is CombinedService<TExtend> {\n  return (\n    \"children\" in service &&\n    Array.isArray(service.children) &&\n    service.children.length > 0\n  );\n}\n\nexport class CombinedService<\n  TExtend = Record<string, never>,\n> extends Service<TExtend> {\n  children: Service<TExtend>[];\n  logo?: string;\n\n  constructor({ children, logo, ...options }: CombinedServiceOptions<TExtend>) {\n    super(options);\n    this.logo = logo;\n    this.children = children;\n  }\n}\n\n/**\n * Utility method for creating a single Axiom Service out of many independent services.\n * Useful when spinning up many microservices as a monolithic gateway bound to a single port.\n *\n * This method skips the regular bind phase of each service and instead creates an independent\n * Router for each service on which that services middleware and individual controllers are mounted\n * at the appropriate prefix.\n */\nexport function combineServices<TExtend = Record<string, never>>(\n  services: Service<TExtend>[],\n  config?: CombinedServiceConfiguration\n): Service<TExtend> {\n  const combinedConfig = {\n    ...DEFAULT_COMBINED_SERVICE_CONFIGURATION,\n    ...config,\n  };\n  const combinedService = new CombinedService<TExtend>({\n    servers: combinedConfig.servers,\n    title: combinedConfig.title,\n    description: combinedConfig.description,\n    logo: combinedConfig.logo,\n    tags: combinedConfig.tags,\n    children: services,\n    license: combinedConfig.license,\n    onError: combinedConfig.onError,\n  });\n\n  for (const service of services) {\n    service.config = combinedConfig;\n    service.init(combinedService.router);\n    service.onError = combinedService.onError;\n  }\n\n  return combinedService;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAAA,kBAAkC;AAClC,IAAAC,gBAAsB;AACtB,gBAAe;AACf,8BAAuB;AACvB,kBAAiB;AACjB,kCAAsB;;;ACNtB,oBAAmB;AACnB,iBAA8C;AAC9C,4BAAuB;AACvB,oBAAkB;AAClB,2BAAmB;AACnB,0BAAwB;;;ACNxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAAc;AACd,qBAAqC;AACrC,mBAAsB;AACtB,sBAA6B;AAC7B,oBAA2B;;;ADJ3B,2BAAc;;;AE8BP,IAAM,QAAN,MAWL;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAQA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAKA,YACE,SAUA;AACA,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW,QAAQ;AACxB,SAAK,QAAQ,QAAQ;AACrB,SAAK,UAAU;AAAA,MACb,OAAO,QAAQ;AAAA,MACf,QAAQ,QAAQ,UAAW,QAAQ;AAAA,MACnC,QAAQ,QAAQ,UAAW,QAAQ;AAAA,MACnC,KAAK,QAAQ,OAAQ,oBAAE,OAAO,CAAC,CAAC;AAAA,MAChC,MAAM,QAAQ,QAAS,oBAAE,OAAO,CAAC,CAAC;AAAA,MAClC,OAAO,QAAQ,SAAU,oBAAE,OAAO,CAAC,CAAC;AAAA,IACtC;AACA,SAAK,cAAc,QAAQ;AAC3B,SAAK,aACH,QAAQ,cAAe,QAAQ;AACjC,SAAK,yBAAyB,QAAQ,0BAA0B;AAChE,SAAK,iBAAiB,QAAQ,iBAC1B;AAAA,MACE,SAAS,QAAQ,eAAe;AAAA,MAChC,cAAc,QAAQ,eAAe,gBAAgB;AAAA,IACvD,IACA;AAAA,EACN;AAAA,EAEA,wBAAiC;AAC/B,WAAO,oBAAE,OAAO;AAAA,MACd,SAAS,oBAAE,MAAM,KAAK,QAAQ,KAAK;AAAA,MACnC,YAAY,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,MACjC,OAAO,oBAAE,OAAO;AAAA,MAChB,UAAU,oBAAE,OAAO;AAAA,QACjB,gBAAgB,oBAAE,OAAO;AAAA,QACzB,mBAAmB,oBAAE,OAAO;AAAA,QAC5B,mBAAmB,oBAAE,MAAM,CAAC,oBAAE,OAAO,GAAG,oBAAE,OAAO,CAAC,CAAC;AAAA,MACrD,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,sBAA+B;AAC7B,WAAO,oBAAE,OAAO;AAAA,MACd,QAAQ,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,MAC7B,OAAO,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,MAC5B,QAAQ,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,MAC7B,SAAS,oBAAE;AAAA,QACT,oBAAE;AAAA,UACA,oBAAE,OAAO;AAAA,YACP,OAAO,oBAAE,OAAO;AAAA,YAChB,UAAU,oBAAE,MAAM;AAAA,cAChB,oBAAE,QAAQ,IAAI;AAAA,cACd,oBAAE,QAAQ,UAAU;AAAA,cACpB,oBAAE,QAAQ,IAAI;AAAA,cACd,oBAAE,QAAQ,IAAI;AAAA,cACd,oBAAE,QAAQ,SAAS;AAAA,YACrB,CAAC;AAAA,YACD,OAAO,oBAAE,MAAM;AAAA,cACb,oBAAE,OAAO;AAAA,cACT,oBAAE,OAAO;AAAA,cACT,oBAAE,QAAQ;AAAA,cACV,oBAAE,MAAM,oBAAE,MAAM,CAAC,oBAAE,OAAO,GAAG,oBAAE,OAAO,CAAC,CAAC,CAAC;AAAA,YAC3C,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,MAAM,oBAAE;AAAA,QACN,oBAAE,OAAO;AAAA,UACP,OAAO,oBAAE,OAAO;AAAA,UAChB,WAAW,oBAAE,MAAM,CAAC,oBAAE,QAAQ,KAAK,GAAG,oBAAE,QAAQ,MAAM,CAAC,CAAC;AAAA,QAC1D,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,SAAS,YAUd,SAUA;AACA,SAAO,IAAI,MAST,OAAO;AACX;;;AChKO,IAAM,YAAN,MAIL;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAsD;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,SAAqD;AAC/D,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW,QAAQ;AACxB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS,QAAQ;AACtB,SAAK,QAAQ,QAAQ,SAAU,oBAAE,OAAO,CAAC,CAAC;AAC1C,SAAK,SAAS,QAAQ,UAAU;AAAA,EAClC;AACF;AAEO,SAAS,gBAId,SAAqD;AACrD,SAAO,IAAI,UAAU,OAAO;AAC9B;;;ACxCO,SAAS,iCAAmD,KAAQ;AACzE,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,QAAQ,MAAM,GAAG,GAAG,GAAG,CAAC;AAAA,EACvE;AACF;AAEO,SAAS,mCAAqD,KAAQ;AAC3E,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,QAAQ,MAAM,GAAG,GAAG,GAAG,CAAC;AAAA,EACvE;AACF;AAEO,SAAS,SAKd,MACAC,OACA,cACuC;AACvC,QAAM,QAAQA,MACX,MAAM,QAAQ,EACd,OAAO,OAAO,EACd;AAAA;AAAA,IAEC,CAACC,QAAO,QAASA,SAAgB,GAAG;AAAA,IACpC;AAAA,EACF;AAEF,SAAO,UAAU,SAAY,QAAS;AACxC;AAEO,SAAS,SAA4B,QAAW;AACrD,SAAO,qBAAK,OAAyB,EAAE,GAAG,QAAQ,UAAU,KAAK,CAAC;AACpE;AAEO,SAAS,+BACd,QACG;AACH,MAAI,yBAAU,QAAQ,MAAM,GAAG;AAC7B,WAAO,EAAE,GAAG,QAAQ,OAAO,+BAA+B,OAAO,KAAK,EAAE;AAAA,EAC1E;AACA,MAAI,yBAAU,SAAS,MAAM,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,sBAAsB;AAAA,MACtB,YAAY,OAAO;AAAA,QACjB,OAAO,QAAQ,OAAO,UAAU,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,UACtD;AAAA,UACA,+BAA+B,KAAK;AAAA,QACtC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,6BAAgD,QAAc;AAC5E,MAAI,yBAAU,QAAQ,MAAM,GAAG;AAC7B,WAAO,EAAE,GAAG,QAAQ,OAAO,6BAA6B,OAAO,KAAK,EAAE;AAAA,EACxE;AACA,MAAI,yBAAU,SAAS,MAAM,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY,OAAO;AAAA,QACjB,OAAO,QAAQ,OAAO,UAAU,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,UACtD;AAAA,UACA,6BAA6B,KAAK;AAAA,QACpC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,MAAI,yBAAU,SAAS,MAAM,KAAK,OAAO,OAAO,WAAW,aAAa;AACtE,WAAO;AAAA,MACL,GAAG;AAAA,MACH,SAAS;AAAA,IACX;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,oBAAuC,QAAc;AACnE,MAAI,yBAAU,QAAQ,MAAM,GAAG;AAC7B,WAAO,EAAE,GAAG,QAAQ,OAAO,oBAAoB,OAAO,KAAK,EAAE;AAAA,EAC/D;AACA,MAAI,yBAAU,SAAS,MAAM,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY,OAAO;AAAA,QACjB,OAAO,QAAQ,OAAO,UAAU,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,UACtD;AAAA,UACA,oBAAoB,KAAK;AAAA,QAC3B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,MAAI,yBAAU,SAAS,MAAM,KAAK,OAAO,OAAO,WAAW,aAAa;AACtE,WAAO;AAAA,MACL,GAAG;AAAA,MACH,QAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,iBAAoC,QAAc;AAChE,MAAI,yBAAU,QAAQ,MAAM,GAAG;AAC7B,WAAO,EAAE,GAAG,QAAQ,OAAO,iBAAiB,OAAO,KAAK,EAAE;AAAA,EAC5D;AACA,MAAI,yBAAU,SAAS,MAAM,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY,OAAO;AAAA,QACjB,OAAO,QAAQ,OAAO,UAAU,EAC7B,OAAO,CAAC,CAAC,EAAE,KAAK,MAAM;AACrB,iBAAO,CAAC,yBAAU,QAAQ,KAAK;AAAA,QACjC,CAAC,EACA,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,iBAAiB,KAAK,CAAC,CAAC;AAAA,MACzD;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,2BAA8C,QAAc;AAC1E,MAAI,yBAAU,QAAQ,MAAM,GAAG;AAC7B,WAAO,EAAE,GAAG,QAAQ,OAAO,2BAA2B,OAAO,KAAK,EAAE;AAAA,EACtE;AACA,MAAI,yBAAU,SAAS,MAAM,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY,OAAO;AAAA,QACjB,OAAO,QAAQ,OAAO,UAAU,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,UACtD;AAAA,UACA,2BAA2B,KAAK;AAAA,QAClC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,MAAI,yBAAU,OAAO,MAAM,GAAG;AAC5B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,MACN,QAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,oBAAsC,KAAoB;AACxE,SAAO,OAAO,QAAQ,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM;AACrD,QAAI,QAAQ,IAAI;AACd,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,IAAI;AAAA,IAC9B;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAe;AACrB;AAEO,SAAS,uBAA6B,QAAW,OAAa;AACnE,MAAI,yBAAU,QAAQ,MAAM,KAAK,MAAM,QAAQ,KAAK,GAAG;AACrD,WAAO,MAAM;AAAA,MACX,CAAC,SAAS,uBAAuB,OAAO,OAAO,IAAI;AAAA,IACrD;AAAA,EACF;AACA,MACE,yBAAU,SAAS,MAAM,KACzB,OAAO,UAAU,YACjB,UAAU,MACV;AACA,UAAM,cAA0B,CAAC;AACjC,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAChD,UAAI,OAAO,OAAO,YAAY;AAC5B,oBAAY,GAAc,IAAI;AAAA,UAC5B,OAAO,WAAW,GAAG;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,wBAA2C,QAAW;AACpE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,YAAY,OAAO;AAAA,MACjB,OAAO,QAAQ,OAAO,UAAU,EAAE;AAAA,QAChC,CAAC,CAAC,EAAE,IAAI,MAAM,CAAC,yBAAU,QAAQ,IAAI,KAAK,CAAC,yBAAU,SAAS,IAAI;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,gBAAkC,OAAU;AAC1D,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,MAC1C;AAAA,MACA,UAAU,SAAY,OAAO;AAAA,IAC/B,CAAC;AAAA,EACH;AACF;AAEO,SAAS,0BAA4C,OAAU;AACpE,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,MAC1C;AAAA,MACA,UAAU,SAAS,OAAO,UAAU,UAAU,QAAQ;AAAA,IACxD,CAAC;AAAA,EACH;AACF;AAEO,SAAS,KAAwB,QAAW,OAAgB;AACjE,SAAO,mBAAM,KAAK,QAAQ,KAAK;AACjC;;;AC1NA,6BAA4B;AAErB,IAAK,YAAL,kBAAKC,eAAL;AAEL,EAAAA,WAAA,gBAAa;AAEb,EAAAA,WAAA,kBAAe;AAEf,EAAAA,WAAA,eAAY;AAEZ,EAAAA,WAAA,cAAW;AAEX,EAAAA,WAAA,yBAAsB;AAVZ,SAAAA;AAAA,GAAA;AAaL,IAAM,WAAN,cAAuB,mCAAY;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AAAA,EACA,YACE,QACA,SACA,SAAiC,CAAC,GAClC;AACA,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAChB;AACF;AAEO,SAAS,WAAW,OAAmC;AAC5D,SACE,CAAC,CAAC,SACF,OAAO,UAAU,YACjB,YAAY,SACZ,OAAO,MAAM,WAAW;AAE5B;AAEO,IAAM,kBAAN,cAA8B,SAAS;AAAA,EAC5C;AAAA,EACA,YAAY,SAAkB,aAAsC;AAClE,UAAM,KAAK,WAAW,aAAa;AACnC,SAAK,OAAO;AACZ,SAAK,SAAS,eAAe,CAAC;AAAA,EAChC;AACF;AAEO,SAAS,kBAAkB,OAA2C;AAC3E,SAAO,MAAM,SAAS,iCAAwB,MAAM,WAAW;AACjE;AAEO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAC9C,YAAY,SAAkB,QAAiC;AAC7D,UAAM,KAAK,WAAW,gBAAgB,MAAM;AAC5C,SAAK,OAAO;AAAA,EACd;AACF;AAEO,SAAS,oBACd,OAC4B;AAC5B,SAAO,MAAM,SAAS,qCAA0B,MAAM,WAAW;AACnE;AAEO,IAAM,iBAAN,cAA6B,SAAS;AAAA,EAC3C,YAAY,SAAkB,QAAiC;AAC7D,UAAM,KAAK,WAAW,aAAa,MAAM;AACzC,SAAK,OAAO;AAAA,EACd;AACF;AAEO,SAAS,iBAAiB,OAA0C;AACzE,SAAO,MAAM,SAAS,+BAAuB,MAAM,WAAW;AAChE;AAEO,IAAM,gBAAN,cAA4B,SAAS;AAAA,EAC1C,YAAY,SAAkB,QAAiC;AAC7D,UAAM,KAAK,WAAW,aAAa,MAAM;AACzC,SAAK,OAAO;AAAA,EACd;AACF;AAEO,SAAS,gBAAgB,OAAyC;AACvE,SAAO,MAAM,SAAS,6BAAsB,MAAM,WAAW;AAC/D;AAEO,IAAM,sBAAN,cAAkC,SAAS;AAAA,EAChD,YAAY,SAAkB,QAAiC;AAC7D,UAAM,KAAK,WAAW,yBAAyB,MAAM;AACrD,SAAK,OAAO;AAAA,EACd;AACF;AAEO,SAAS,sBACd,OAC8B;AAC9B,SAAO,MAAM,SAAS,mDAAiC,MAAM,WAAW;AAC1E;AAEO,IAAM,SAAS,CACpB,WACA,SACA,QAAQ,oBACL;AACH,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,OAAO;AAAA,EACzB;AACF;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAc;;;ACQP,IAAM,uBAAuB,oBAAE,OAAO;AAAA,EAC3C,gBAAgB,oBAAE,OAAO;AAAA,EACzB,mBAAmB,oBAAE,OAAO;AAAA,EAC5B,mBAAmB,oBAAE,MAAM,CAAC,oBAAE,OAAO,GAAG,oBAAE,OAAO,CAAC,CAAC;AACrD,CAAC;AASM,IAAM,uBAAuB,oBAAE,OAAO;AAAA,EAC3C,SAAS,oBAAE,MAAM,oBAAE,IAAI,CAAC;AAAA,EACxB,YAAY,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,EACjC,OAAO,oBAAE,OAAO;AAAA,EAChB,UAAU;AACZ,CAAC;AAQM,IAAM,qBAAqB,oBAAE,OAAO;AAAA,EACzC,OAAO,oBAAE,OAAO;AAAA,EAChB,UAAU,oBAAE,MAAM;AAAA,IAChB,oBAAE,QAAQ,IAAI;AAAA,IACd,oBAAE,QAAQ,UAAU;AAAA,IACpB,oBAAE,QAAQ,IAAI;AAAA,IACd,oBAAE,QAAQ,IAAI;AAAA,IACd,oBAAE,QAAQ,SAAS;AAAA,EACrB,CAAC;AAAA,EACD,OAAO,oBAAE,MAAM;AAAA,IACb,oBAAE,OAAO;AAAA,IACT,oBAAE,OAAO;AAAA,IACT,oBAAE,QAAQ;AAAA,IACV,oBAAE,MAAM,oBAAE,MAAM,CAAC,oBAAE,OAAO,GAAG,oBAAE,OAAO,CAAC,CAAC,CAAC;AAAA,EAC3C,CAAC;AACH,CAAC;AAYM,IAAM,qBAAqB,oBAAE,OAAO;AAAA,EACzC,QAAQ,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,EAC7B,OAAO,oBAAE,OAAO;AAAA,EAChB,QAAQ,oBAAE,SAAS,oBAAE,OAAO,CAAC;AAAA,EAC7B,MAAM,oBAAE;AAAA,IACN,oBAAE,OAAO;AAAA,MACP,OAAO,oBAAE,OAAO;AAAA,MAChB,WAAW,oBAAE,MAAM,CAAC,oBAAE,QAAQ,KAAK,GAAG,oBAAE,QAAQ,MAAM,CAAC,CAAC;AAAA,IAC1D,CAAC;AAAA,EACH;AACF,CAAC;AAkCM,IAAM,oBAAoB,CAC/B,WAEA,OAAO;AAAA,EACL,CACE,KACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MACG;AACH,QAAI,OAAO,OAAO,aAAa;AAC7B,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aAAa,GAAG,UAAU,IAAI,EAAE,KAAK;AAAA,MAC/C;AAAA,IACF;AACA,QAAI,OAAO,WAAW,aAAa;AACjC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aAAa,GAAG,UAAU,KAAK,MAAM,KAAK,IAAI,MAAM;AAAA,MAC9D;AAAA,IACF;AACA,QAAI,OAAO,YAAY,aAAa;AAClC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aACJ,GAAG,UAAU,IAAI,QAAQ,KAAK,GAAG,CAAC,KAClC,QAAQ,KAAK,GAAG;AAAA,MACtB;AAAA,IACF;AAEA,QAAI,OAAO,aAAa,aAAa;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aAAa,GAAG,UAAU,KAAK,QAAQ,MAAM,IAAI,QAAQ;AAAA,MACnE;AAAA,IACF;AAEA,QAAI,OAAO,gBAAgB,aAAa;AACtC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aACJ,GAAG,UAAU,IAAI,YAAY,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC,KAC3D,YAAY,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG;AAAA,MAC/C;AAAA,IACF;AAEA,QAAI,OAAO,kBAAkB,aAAa;AACxC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aACJ,GAAG,UAAU,KAAK,aAAa,KAC/B,IAAI,aAAa;AAAA,MACvB;AAAA,IACF;AAEA,QAAI,OAAO,eAAe,aAAa;AACrC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aACJ,GAAG,UAAU,KAAK,UAAU,KAC5B,IAAI,UAAU;AAAA,MACpB;AAAA,IACF;AAEA,QAAI,OAAO,cAAc,aAAa;AACpC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,aACJ,GAAG,UAAU,KAAK,UAAU,CAAC,CAAC,KAAK,UAAU,CAAC,CAAC,KAC/C,IAAI,UAAU,CAAC,CAAC,KAAK,UAAU,CAAC,CAAC;AAAA,MACvC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EACA,CAAC;AACH;AAEF,SAAS,mBAAmB,OAAyC;AACnE,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,SAAS,SAAS,OAAO,EAAE;AACjC,QAAI,CAAC,OAAO,MAAM,MAAM,GAAG;AACzB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,kBACd,OACoB;AACpB,SAAO,OAAO,QAAQ,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM;AACxD,UAAM,CAAC,eAAe,SAAS,IAAI,IAAI,SAAS,GAAG,IAC/C,IAAI,MAAM,GAAG,IACb,CAAC,OAAO,GAAG;AAEf,UAAM,aAAa,kBAAkB,QAAQ,QAAQ;AACrD,UAAM,UAAU,UAAU,SAAS,GAAG;AACtC,UAAM,SAAS,UAAU,UAAU,MAAM,GAAG,IAAI,CAAC,SAAS;AAG1D,QACE,OAAO,WAAW,KAClB,OAAO,CAAC,EAAE,WAAW,GAAG,KACxB,OAAO,CAAC,EAAE,WAAW,GAAG,GACxB;AACA,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,WAAW;AAAA,UACT,mBAAmB,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC;AAAA,UACrC,mBAAmB,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IAGH,WAAW,UAAU,WAAW,GAAG,GAAG;AACpC,YAAM,CAAC,EAAE,KAAK,IAAI,UAAU,MAAM,GAAG;AACrC,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,YAAY,mBAAmB,KAAK;AAAA,MACtC,CAAC;AAAA,IAGH,WAAW,UAAU,WAAW,GAAG,GAAG;AACpC,YAAM,CAAC,EAAE,KAAK,IAAI,UAAU,MAAM,GAAG;AACrC,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,eAAe,mBAAmB,KAAK;AAAA,MACzC,CAAC;AAAA,IAGH,WACE,OAAO,SAAS,KAChB,UAAU,WAAW,GAAG,KACxB,UAAU,SAAS,GAAG,GACtB;AACA,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,aAAa,OAAO,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,EAAE,CAAC;AAAA,MAC/C,CAAC;AAAA,IAGH,WAAW,UAAU,WAAW,GAAG,KAAK,UAAU,SAAS,GAAG,GAAG;AAC/D,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,UAAU,UAAU,MAAM,GAAG,EAAE;AAAA,MACjC,CAAC;AAAA,IAGH,WAAW,OAAO,SAAS,GAAG;AAC5B,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,SAAS;AAAA,MACX,CAAC;AAAA,IAEH,WAAW,OAAO,WAAW,KAAK,UAAU,WAAW,GAAG,GAAG;AAC3D,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,QAAQ,cAAc;AAAA,MACxB,CAAC;AAAA,IAEH,OAAO;AACL,UAAI,KAAK;AAAA,QACP;AAAA,QACA;AAAA,QACA,IAAI,mBAAmB,SAAS;AAAA,MAClC,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,CAAuB;AAC7B;;;ACzRO,IAAM,WAAN,MAA+D;AAAA,EACpE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,SAA0C;AACpD,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW,QAAQ;AACxB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS,QAAQ;AAAA,EACxB;AACF;AAEO,SAAS,eACd,SAC0B;AAC1B,SAAO,IAAI,SAAS,OAAO;AAC7B;;;AT+BO,IAAM,gCAAsD;AAAA,EACjE,MAAM,CAAC;AACT;AAEO,SAAS,UAAU,SAAsC;AAC9D,MAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AACnD,WAAO;AAAA,EACT;AACA,SACE,WAAW,WACX,OAAO,QAAQ,UAAU,YACzB,iBAAiB,WACjB,OAAO,QAAQ,gBAAgB,YAC/B,UAAU,WACV,MAAM,QAAQ,QAAQ,IAAI,KAC1B,YAAY,WACZ,OAAO,QAAQ,WAAW;AAE9B;;;AU/EA,8BAAO;AACP,2CAAoB;AACpB,IAAAC,kBAAmC;AACnC,mBAAsB;AACtB,wBAAsB;AACtB,SAAoB;;;ACuBb,IAAM,yCAAyC;AAAA,EACpD,GAAG;AAAA,EACH,OAAO;AAAA,EACP,aAAa;AAAA,EACb,MAAM,CAAC;AAAA,EACP,SAAS;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,EACP;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,IACN,KAAK;AAAA,EACP;AACF;AAEO,SAAS,kBACd,SACqC;AACrC,SACE,cAAc,WACd,MAAM,QAAQ,QAAQ,QAAQ,KAC9B,QAAQ,SAAS,SAAS;AAE9B;;;ADvCA,IAAM,UAAM,oBAAM,oBAAoB;AAOtC,eAAe,iBAA0B,QAAiB;AACxD,QAAM,gBAAY,qCAAAC,SAAQ,MAAgB;AAC1C,SAAO;AACT;AAEA,IAAM,aAAa,CAACC,UAAiB;AACnC,QAAM,YAAYA,MACf,MAAM,GAAG,EACT,IAAI,CAAC,SAAS;AACb,QAAI,KAAK,SAAS,GAAG,GAAG;AACtB,aAAO,IAAI,KAAK,QAAQ,KAAK,EAAE,CAAC;AAAA,IAClC;AACA,WAAO;AAAA,EACT,CAAC,EACA,KAAK,GAAG;AAEX,MAAI,cAAc,KAAK;AACrB,WAAO;AAAA,EACT;AAEA,SAAO,UAAU,SAAS,GAAG,IACzB,UAAU,MAAM,GAAG,UAAU,SAAS,CAAC,IACvC;AACN;AAEA,IAAM,QAAQ,CAAC,QAAgB;AAC7B,QAAM,WAAW,IAAI,QAAQ,OAAO,EAAE;AACtC,aAAO,kBAAAC,SAAU,QAAQ,EAAE,UAAU,CAAC,GAAG,kBAAkB,KAAK;AAClE;AAQA,IAAM,2BAA4C;AAAA,EAChD,QAAQ;AACV;AAEA,eAAsB,SACpB,QACA;AAAA,EACE,SAAS;AAAA,EACT,WAAW;AAAA,EACX,WAAW,CAAC;AACd,IAAqB,0BACrB;AACA,MAAI,wCAAwC,MAAM;AAClD,QAAM,OAAU,SAAM,eAAe,OAAO,EACzC,SAAS,OAAO,KAAK,EACrB,eAAe,OAAO,WAAW,EACjC,WAAW,OAAO,OAAO,EACzB,kBAAkB,OAAO;AAAA,IACxB,cAAc;AAAA,IACd,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,aACE;AAAA,EACJ,CAAC,EACA,YAAY,OAAO;AAAA,IAClB,aAAa;AAAA,IACb,SAAS;AAAA,MACP,oBAAoB;AAAA,QAClB,QAAQ;AAAA,UACN,YAAY;AAAA,YACV,QAAQ,EAAE,MAAM,SAAS;AAAA,YACzB,SAAS,EAAE,MAAM,SAAS;AAAA,UAC5B;AAAA,UACA,SAAS;AAAA,YACP,QAAQ;AAAA,YACR,SACE;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC,EACA,YAAY,OAAO;AAAA,IAClB,aAAa;AAAA,IACb,SAAS;AAAA,MACP,oBAAoB;AAAA,QAClB,QAAQ;AAAA,UACN,YAAY;AAAA,YACV,QAAQ,EAAE,MAAM,SAAS;AAAA,YACzB,SAAS,EAAE,MAAM,SAAS;AAAA,UAC5B;AAAA,UACA,SAAS;AAAA,YACP,QAAQ;AAAA,YACR,SAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC,EACA,YAAY,OAAO;AAAA,IAClB,aAAa;AAAA,IACb,SAAS;AAAA,MACP,oBAAoB;AAAA,QAClB,QAAQ;AAAA,UACN,YAAY;AAAA,YACV,QAAQ,EAAE,MAAM,SAAS;AAAA,YACzB,SAAS,EAAE,MAAM,SAAS;AAAA,UAC5B;AAAA,UACA,SAAS;AAAA,YACP,QAAQ;AAAA,YACR,SACE;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC,EACA,YAAY,OAAO;AAAA,IAClB,aAAa;AAAA,IACb,SAAS;AAAA,MACP,oBAAoB;AAAA,QAClB,QAAQ;AAAA,UACN,YAAY;AAAA,YACV,QAAQ,EAAE,MAAM,SAAS;AAAA,YACzB,SAAS,EAAE,MAAM,SAAS;AAAA,UAC5B;AAAA,UACA,SAAS;AAAA,YACP,QAAQ;AAAA,YACR,SAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AAEH,MAAI,OAAO,SAAS;AAClB,SAAK,WAAW,OAAO,OAAO;AAAA,EAChC;AAEA,aAAW,UAAU,OAAO,SAAS;AACnC,SAAK,UAAU,MAAM;AAAA,EACvB;AAEA,MAAI,kBAAkB,MAAM,GAAG;AAC7B,QAAI,4DAA4D;AAEhE,QAAI,OAAO,MAAM;AACf,WAAK,QAAQ,KAAK,QAAQ,IAAI;AAAA,QAC5B,KAAK,OAAO;AAAA,QACZ,SAAS,OAAO;AAAA,MAClB;AAAA,IACF;AAEA,WAAO,SACJ,OAAO,CAAC,YAAY,CAAC,QAAQ,YAAY,QAAQ,EACjD,QAAQ,CAAC,YAAY;AACpB,UAAI,sBAAsB,QAAQ,KAAK,EAAE;AACzC,WAAK,OAAO;AAAA,QACV,MAAM,QAAQ;AAAA,QACd,aAAa,QAAQ;AAAA,MACvB,CAAC;AACD,cAAQ,OAAO,CAAC,QAAQ,KAAK;AAAA,IAC/B,CAAC;AAAA,EACL;AAEA,MAAI,SAAS,SAAS,GAAG;AACvB,QAAI,qCAAqC;AACzC,SAAK,QAAQ,aAAa,IAAI,SAAS,IAAI,CAAC,aAAa;AAAA,MACvD,MAAM,QAAQ;AAAA,MACd,MAAM,QAAQ;AAAA,IAChB,EAAE;AAAA,EACJ;AAEA,QAAM,mBAOF,CAAC;AAEL,QAAM,WAAW,kBAAkB,MAAM,IAAI,OAAO,WAAW,CAAC,MAAM;AAEtE,MAAI,SAAS,SAAS,MAAM,WAAW;AAEvC,WACG,OAAO,CAAC,YAAY,CAAC,QAAQ,YAAY,QAAQ,EACjD,QAAQ,CAAC,YAAY;AACpB,QAAI,kCAAkC,QAAQ,KAAK,EAAE;AACrD,YAAQ,YACL,OAAO,CAAC,eAAe,CAAC,WAAW,YAAY,QAAQ,EACvD,QAAQ,CAAC,eAAe;AACvB,YAAM,MAAM,WAAW,cAAc;AACrC,UAAI,SAAS,IAAI,MAAM,4BAA4B;AACnD,UAAI,QAAQ,CAAC,CAAC,EAAE,MAAM;AACpB;AAAA,UACE,cAAc,GAAG,OAAO,YAAY,CAAC,IAAI,WAAW,MAAM,GACxD,GAAG,IACL,KAAK,GAAG,IAAI;AAAA,QACd;AACA,cAAMD,QAAO,GACX,CAAC,IAAI,GAAG,EAAE,SAAS,QAAQ,MAAM,IAAI,KAAK,QAAQ,MACpD,GAAG,WAAW,MAAM,GAAG,GAAG,IAAI;AAE9B,YAAI,CAAC,MAAM,QAAQ,iBAAiBA,KAAI,CAAC,GAAG;AAC1C,2BAAiBA,KAAI,IAAI,CAAC;AAAA,QAC5B;AAEA,yBAAiBA,KAAI,EAAE,KAAK;AAAA,UAC1B,GAAG;AAAA,UACH,MAAM;AAAA,YACJ,GAAG,oBAAI,IAAI,CAAC,GAAG,QAAQ,MAAM,GAAG,WAAW,MAAM,GAAG,GAAG,IAAI,CAAC;AAAA,UAC9D;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACL,CAAC;AAEH,MAAI,+DAA+D;AAEnE,aAAWA,SAAQ,OAAO,KAAK,gBAAgB,GAAG;AAChD,QAAI,uCAAuCA,KAAI,EAAE;AACjD,QAAI,UAAmC,CAAC;AACxC,UAAM,aAAa,iBAAiBA,KAAI,EAAE,OAAO,CAAC,OAAO;AACvD,aAAQ,CAAC,GAAG,YAAY,CAAC,GAAG,WAAW,YAAa;AAAA,IACtD,CAAC;AACD,QAAI,SAAS,WAAW,MAAM,wBAAwBA,KAAI,EAAE;AAE5D,UAAM,CAAC,KAAK,IAAI;AAChB,QAAI,OAAO;AACT,UAAI,oBAAoB,MAAM,IAAI,IAAI,MAAM,MAAM,IAAI,MAAM,IAAI,EAAE;AAElE,cAAQ,aAAa,OAAO,KAAK,MAAM,OAAO,UAAU,EAAE,IAAI,CAAC,SAAS;AAAA,QACtE,MAAM;AAAA,QACN,IAAI;AAAA;AAAA,QAEJ,UAAU,MAAM,OAAO,SAAS,SAAS,GAAG;AAAA;AAAA,QAE5C,QAAQ,EAAE,MAAM,UAAU,QAAQ,MAAM,OAAO,WAAW,GAAG,EAAE,OAAO;AAAA;AAAA,QAEtE,aAAa,MAAM,OAAO,WAAW,GAAG,EAAE;AAAA;AAAA,QAE1C,SAAS,MAAM,OAAO,WAAW,GAAG,EAAE;AAAA;AAAA,QAEtC,UAAU,MAAM,OAAO,WAAW,GAAG,EAAE;AAAA,MACzC,EAAE;AAAA,IACJ;AAEA,QAAI,oBAAoB,KAAK,UAAU,QAAQ,UAAU,CAAC,EAAE;AAE5D,eAAW,MAAM,YAAY;AAC3B,UAAI,wBAAwB,GAAG,IAAI,IAAI,GAAG,MAAM,IAAI,GAAG,IAAI,EAAE;AAC7D,UAAI,CAAC,0BAAU,SAAS,GAAG,MAAM,GAAG;AAClC,cAAM,IAAI;AAAA,UACR,2DAA2D,GAAG,IAAI,IAAI,GAAG,MAAM,IAAI,GAAG,IAAI;AAAA,QAC5F;AAAA,MACF;AAEA,UAAI,CAAC,0BAAU,SAAS,GAAG,KAAK,GAAG;AACjC,cAAM,IAAI;AAAA,UACR,sDAAsD,GAAG,IAAI,IAAI,GAAG,MAAM,IAAI,GAAG,IAAI;AAAA,QACvF;AAAA,MACF;AAEA,UAAI,OAAO,KAAK,UAAU,GAAG,KAAK,MAAM,EAAE,CAAC;AAC3C,UAAI,OAAO,KAAK,UAAU,GAAG,KAAK,MAAM,EAAE,CAAC;AAE3C,gBAAU;AAAA,QACR,GAAG;AAAA,QACH,CAAC,GAAG,MAAM,GAAG;AAAA,UACX,aAAa,MAAM,GAAG,IAAI;AAAA,UAC1B,SAAS,GAAG,WAAW;AAAA,UACvB,aAAa,GAAG,cAAc,GAAG,cAAc;AAAA,UAC/C,MAAM,GAAG;AAAA,UACT,GAAI,CAAC,QAAQ,KAAK,EAAE,SAAS,GAAG,MAAM,IAClC;AAAA,YACE,aAAa;AAAA,cACX,SAAS;AAAA,gBACP,oBAAoB;AAAA,kBAClB,QAAQ,MAAM;AAAA,oBACZ,2BAA2B,GAAG,GAAG;AAAA,kBACnC;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF,IACA,CAAC;AAAA,UACL,YAAY,OAAO,KAAK,GAAG,MAAM,UAAU,EAAE,IAAI,CAAC,UAAU;AAAA,YAC1D,MAAM;AAAA,YACN,QAAQ;AAAA,cACN,MAAM;AAAA;AAAA,cAEN,QAAQ,GAAG,MAAM,WAAW,IAAI,EAAE;AAAA,YACpC;AAAA,YACA,IAAI;AAAA;AAAA,YAEJ,aAAa,GAAG,MAAM,WAAW,IAAI,EAAE;AAAA,UACzC,EAAE;AAAA,UACF,UAAU,GAAG,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC;AAAA,UACrC,WAAW;AAAA,YACT,KAAK;AAAA,cACH,aAAa,GAAG,IAAI,eAAe;AAAA,cACnC,SAAS;AAAA,gBACP,oBAAoB;AAAA,kBAClB,QAAQ,MAAM;AAAA,oBACZ,2BAA2B,GAAG,GAAG;AAAA,kBACnC;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,YACA,KAAK,EAAE,MAAM,6BAA6B;AAAA,YAC1C,KAAK,EAAE,MAAM,6BAA6B;AAAA,YAC1C,KAAK,EAAE,MAAM,6BAA6B;AAAA,YAC1C,KAAK,EAAE,MAAM,6BAA6B;AAAA,UAC5C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,eAAeA,KAAI,IAAI,OAAO;AAElC,SAAK,QAAQ,WAAWA,KAAI,GAAG,OAAO;AAAA,EACxC;AAEA,MAAI,WAAW,QAAQ;AACrB,WAAO,KAAK,cAAc;AAAA,EAC5B;AACA,SAAO,KAAK,cAAc;AAC5B;;;AX/UA,wBAAAE,QAAW,SAAS,QAAQ,CAAC,SAAS,KAAK,MAAM,IAAI,CAAC;AAEtD,IAAM,iBAAiB,gBAAAC,KAAE,OAAO;AAAA,EAC9B,OAAO,gBAAAA,KAAE,OAAO,EAAE,SAAS,WAAW,CAAC;AAAA,EACvC,QAAQ,gBAAAA,KAAE,OAAO,EAAE,SAAS,WAAW,CAAC;AAAA,EACxC,UAAU,gBAAAA,KAAE,QAAQ,EAAE,SAAS,MAAM,CAAC;AAAA,EACtC,QAAQ,gBAAAA,KAAE,MAAM,CAAC,gBAAAA,KAAE,QAAQ,MAAM,GAAG,gBAAAA,KAAE,QAAQ,MAAM,CAAC,GAAG,EAAE,SAAS,OAAO,CAAC;AAAA,EAC3E,UAAU,gBAAAA,KAAE;AAAA,IACV,gBAAAA,KAAE;AAAA,MACA,gBAAAA,KAAE,OAAO;AAAA,QACP,OAAO,gBAAAA,KAAE,OAAO;AAAA,QAChB,MAAM,gBAAAA,KAAE,MAAM,gBAAAA,KAAE,OAAO,CAAC;AAAA,MAC1B,CAAC;AAAA,IACH;AAAA,EACF;AACF,CAAC;AAID,IAAM,eAAe,gBAAAA,KAAE,OAAO;AAAA,EAC5B,QAAQ,gBAAAA,KAAE,SAAS,gBAAAA,KAAE,OAAO,CAAC;AAAA,EAC7B,MAAM,gBAAAA,KAAE,SAAS,gBAAAA,KAAE,QAAQ,CAAC;AAC9B,CAAC;AAID,IAAM,QAAQ,CAAC,YAAoB;AAEjC,UAAQ,MAAM,OAAO,OAAO,EAAE;AAC9B,UAAQ,KAAK,CAAC;AAChB;AAEA,IAAM,OAAO,IAAI,SAAgB;AAE/B,UAAQ,KAAK,OAAO,GAAG,IAAI;AAC7B;AAEA,IAAM,cAAc,MAAM;AACxB,MAAI;AACF,UAAM,WAAO;AAAA,MACX;AAAA,QACE,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,UACV,aAAa;AAAA,UACb,cAAc;AAAA,QAChB;AAAA,QACA,MAAM;AAAA,UACJ,MAAM;AAAA,UACN,UAAU;AAAA,UACV,OAAO;AAAA,UACP,aAAa;AAAA,QACf;AAAA,MACF;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,uBAAuB;AAAA,UACrB;AAAA,YACE,QAAQ;AAAA,YACR,SACE;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,SAAS,KAAK;AACZ,QAAI,eAAe,OAAO;AACxB,aAAO,MAAM,IAAI,OAAO;AAAA,IAC1B;AACA,WAAO,MAAM,4CAA4C;AAAA,EAC3D;AACF;AAEA,IAAM,wBAAwB,CAAC,aAA6C;AAC1E,MAAI,SAAS,SAAS;AACpB,WAAO,sBAAsB,SAAS,OAAO;AAAA,EAC/C;AACA,SAAO;AACT;AAEA,eAAe,UAAU,OAAe;AACtC,QAAM,WAAW,MAAM,OAAO;AAC9B,QAAM,UAAU,sBAAsB,QAAQ;AAC9C,SAAO;AACT;AAEA,SAAS,UAAU,YAAqB;AACtC,MAAI;AAGF,UAAM,SAAS,oBAAM,KAAK,gBAAgB,CAAC,CAAC;AAG5C,WAAO,QAAQ,YAAAC,QAAK,QAAQ,OAAO,KAAK;AACxC,WAAO,SAAS,YAAAA,QAAK,QAAQ,OAAO,MAAM;AAE1C,WAAO;AAAA,EACT,SAAS,KAAK;AACZ,QAAI,eAAe,OAAO;AACxB,aAAO;AAAA,QACL,oCAAoC,cAAc,cAAc,KAAK,IAAI,OAAO;AAAA,MAClF;AAAA,IACF;AACA,WAAO,MAAM,kCAAkC;AAAA,EACjD;AACF;AAEA,eAAe,OAAO;AACpB,QAAM,OAAO,YAAY;AACzB,QAAM,SAAS,UAAU,KAAK,MAAM;AACpC,QAAM,UAAU,MAAM,UAAU,OAAO,KAAK;AAE5C,MAAI,CAAC,UAAU,OAAO,GAAG;AACvB,WAAO,MAAM,6CAA6C;AAAA,EAC5D;AAEA,QAAM,UAAU,MAAM,SAAS,SAAS,MAAM;AAC9C,YAAAC,QAAG,cAAc,YAAAD,QAAK,QAAQ,OAAO,MAAM,GAAG,SAAS,EAAE,UAAU,OAAO,CAAC;AAC3E,OAAK,6BAA6B,YAAAA,QAAK,QAAQ,OAAO,MAAM,CAAC;AAC/D;AAEA,KAAK;","names":["import_typebox","import_value","path","value","ErrorType","import_typebox","convert","path","kebabCase","loadConfig","T","path","fs"]}